import java.awt.Color;

/**
 * Representa um terreno do tipo Água na simulação.
 * Este terreno atua como uma barreira natural para animais terrestres,
 * impedindo sua movimentação, mas serve como habitat exclusivo para 
 * plantas aquáticas, especificamente a Vitória-Régia.
 * * @version 1.0
 */
public class Agua extends Terreno
{
    private static final Color COR = new Color(65, 105, 225); // Azul royal

    /**
     * Verifica se um determinado ator pode habitar ou transitar sobre a água.
     * * Regras de habitação:
     * - Animais: Não podem habitar (retorna false).
     * - Vitória-Régia: Pode habitar (retorna true).
     * - Outros atores: Não podem habitar por padrão.
     * * @param ator O ator que deseja ocupar este terreno.
     * @return true se o ator for uma Vitória-Régia, false caso contrário.
     */
    @Override
    public boolean ehHabitavel(Ator ator)
    {
        if (ator instanceof Animal) {
            return false;
        }
        if (ator instanceof VitoriaRegia) {
            return true;
        }
        return false;
    }
    
    /**
     * Retorna a cor associada a este tipo de terreno para renderização.
     * * @return A cor definida para a água.
     */
    @Override
    public Color getCor()
    {
        return COR;
    }
}

import java.awt.Color;
import java.util.List;
import java.util.Random;

/**
 * Classe base para todos os animais na simulação.
 * Implementa a interface Ator e contém a lógica 
 * comum a todos os animais, como envelhecer, reproduzir e morrer.
 */
public abstract class Animal implements Ator
{
    // O gerador de números aleatórios compartilhado por todos os animais.
    protected static final Random rand = new Random();
    
    protected int age;
    protected boolean alive;
    protected Location location;

    /**
     * Cria um novo animal.
     * O animal pode ser criado com idade zero (recém-nascido) ou com uma idade
     * aleatória (para popular a simulação inicial).
     * * @param randomAge true se o animal deve começar com uma idade aleatória,
     * false se deve começar com idade 0.
     */
    public Animal(boolean randomAge)
    {
        age = 0;
        alive = true;
        if(randomAge) {
            age = rand.nextInt(getMaxAge());
        }
    }
    
    /**
     * Executa as ações do animal durante um passo da simulação.
     * O ciclo de vida padrão definido aqui é:
     * 1. O animal envelhece.
     * 2. A fome aumenta (se aplicável à espécie).
     * 3. Se estiver vivo, tenta se reproduzir.
     * 4. Se estiver vivo, tenta se mover para uma nova localização.
     * * @param currentField O campo atual contendo o estado atual da simulação.
     * @param updatedField O campo onde o novo estado está sendo construído.
     * @param newActors Lista onde novos animais criados (filhotes) são adicionados.
     */
    @Override
    public void acao(Field currentField, Field updatedField, List<Ator> newActors)
    {
        incrementAge();
        incrementHunger(); // Implementação vazia para coelhos, com lógica para raposas
        
        if(isAlive()) {
            darALuz(updatedField, newActors);
            
            // Tenta se mover para uma nova localização
            Location newLocation = findMoveLocation(currentField, updatedField);
            if(newLocation != null) {
                setLocation(newLocation);
                updatedField.place(this, newLocation);
            }
            else {
                // Não pode se mover (superlotação)
                setDead();
            }
        }
    }
    
    /**
     * Verifica se o animal ainda está vivo.
     * * @return true se o animal está vivo, false caso contrário.
     */
    @Override
    public boolean isAlive()
    {
        return alive;
    }

    /**
     * Define a localização do animal no campo.
     * * @param location A nova localização (objeto Location).
     */
    @Override
    public void setLocation(Location location)
    {
        this.location = location;
    }
    
    /**
     * Define a localização do animal.
     * @param row A linha.
     * @param col A coluna.
     */
    public void setLocation(int row, int col)
    {
        this.location = new Location(row, col);
    }
    
    /**
     * Marca o animal como morto.
     * O animal será removido da simulação no próximo ciclo de limpeza.
     */
    protected void setDead()
    {
        alive = false;
    }
    
    /**
     * Incrementa a idade do animal.
     * Se a idade exceder a idade máxima, o animal morre.
     */
    protected void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }
    
    /**
     * Gerencia o processo de reprodução do animal.
     * Verifica se nascimentos ocorrem e tenta colocar os filhotes no campo.
     * Os filhotes só são criados se houver espaço livre e habitável adjacente.
     * * @param updatedField O campo onde os filhotes serão colocados.
     * @param newActors A lista para registrar os novos filhotes.
     */
    protected void darALuz(Field updatedField, List<Ator> newActors)
    {
        int births = breed();
        for(int b = 0; b < births; b++) {
            // Usa o método abstrato para criar o tipo correto de animal
            Animal newborn = createNewborn(false);

            // Encontra um local livre E habitável para o filhote
            Location loc = updatedField.freeHabitableAdjacentLocation(location, newborn);

            if(loc != null){ // Só adiciona e posiciona se houver espaço
                newActors.add(newborn);
                newborn.setLocation(loc);
                updatedField.place(newborn, loc);
            }
        }
    }

    /**
     * Calcula o número de nascimentos baseado na probabilidade de reprodução.
     * @return O número de nascimentos (pode ser zero).
     */
    protected int breed()
    {
        int births = 0;
        if(canBreed() && rand.nextDouble() <= getBreedingProbability()) {
            births = rand.nextInt(getMaxLitterSize()) + 1;
        }
        return births;
    }

    /**
     * Verifica se o animal pode se reproduzir.
     * @return true se o animal pode se reproduzir.
     */
    protected boolean canBreed()
    {
        return age >= getBreedingAge();
    }

    // --- Métodos Abstratos (Devem ser implementados pelas subclasses) ---
      
    /**
     * @return A idade máxima para este tipo de animal.
     */
    protected abstract int getMaxAge();
    
    /**
     * @return A idade de reprodução para este tipo de animal.
     */
    protected abstract int getBreedingAge();
    
    /**
     * @return A probabilidade de reprodução (entre 0.0 e 1.0).
     */
    protected abstract double getBreedingProbability();
    
    /**
     * @return O tamanho máximo da ninhada.
     */
    protected abstract int getMaxLitterSize();
    
    /**
     * Cria uma nova instância (filhote) da espécie específica.
     * Funciona como uma fábrica (Factory Method) para garantir que o tipo correto
     * de animal seja criado durante a reprodução.
     * * @param randomAge se true, o animal nasce com idade aleatória; se false, nasce com idade 0.
     * @return Um novo objeto Animal da subclasse correta.
     */
    protected abstract Animal createNewborn(boolean randomAge);
    
    /**
     * Incrementa a fome do animal.
     * Para animais que não têm fome (como coelhos), este método
     * pode ter uma implementação vazia.
     */
    protected abstract void incrementHunger();
    
    /**
     * Encontra uma nova localização para o animal se mover.
     * @param currentField O campo atual (para consulta).
     * @param updatedField O campo atualizado (para verificar espaços livres).
     * @return A nova localização, ou null se não houver local disponível.
     */
    protected abstract Location findMoveLocation(Field currentField, Field updatedField);

    /**
     * Retorna a cor que representa este animal na interface gráfica.
     * * @return Um objeto Color.
     */
    @Override
    public abstract Color getCor();
}

import java.util.List;
import java.awt.Color;

/**
 * Define a interface para qualquer participante (ator) da simulação.
 * Todo ator deve ser capaz de realizar uma ação, informar se está vivo
 * e ter sua localização definida.
 * * @version 1.0
 */
public interface Ator {

    /**
     * Realiza a ação do ator para o passo atual da simulação.
     * @param currentField O campo atual, usado para consulta (ex: procurar comida).
     * @param updatedField O campo atualizado, onde o ator deve se posicionar.
     * @param newActors Uma lista para adicionar novos atores (ex: filhotes).
     */
    void acao(Field currentField, Field updatedField, List<Ator> newActors);
    
    /**
     * Verifica se o ator ainda está vivo.
     * @return true se o ator está vivo, false caso contrário.
     */
    boolean isAlive();
    
    /**
     * Define a localização atual do ator no campo.
     * @param location A nova localização.
     */
    void setLocation(Location location);

    /**
     * Retorna a cor deste ator para a GUI.
     * @return A cor do ator.
     */
    Color getCor();
}

/**
 * Fornece um contador para um participante na simulação.
 * Esta classe mantém uma string de identificação e uma contagem de quantos 
 * participantes deste tipo específico existem atualmente dentro da simulação.
 * * É utilizada pela classe FieldStats para gerar relatórios de população.
 * * @author David J. Barnes and Michael Kolling
 * @version 2002-04-23
 */
public class Counter
{
    // Um nome para este tipo de participante da simulação.
    private String name;

    // Quantos deste tipo existem na simulação.
    private int count;

    /**
     * Inicializa um contador para um dos tipos de simulação.
     * * @param name Um nome identificador, por exemplo "Fox".
     */
    public Counter(String name)
    {
        this.name = name;
        count = 0;
    }
    
    /**
     * Retorna a descrição curta (nome) deste tipo.
     * * @return O nome do tipo associado a este contador.
     */
    public String getName()
    {
        return name;
    }

    /**
     * Retorna a contagem atual para este tipo.
     * * @return A quantidade atual de participantes deste tipo.
     */
    public int getCount()
    {
        return count;
    }

    /**
     * Incrementa a contagem atual em uma unidade.
     */
    public void increment()
    {
        count++;
    }
    
    /**
     * Reinicia a contagem atual para zero.
     * Geralmente chamado no início de um novo passo de contagem estatística.
     */
    public void reset()
    {
        count = 0;
    }
}

import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Random;

/**
 * Representa uma grade retangular de posições de campo.
 * Esta classe atua como uma "camada" que gerencia a posição dos atores (animais e plantas)
 * e fornece acesso à matriz de terrenos subjacente.
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-09
 */
public class Field
{
    private static final Random rand = new Random();
    
    // A profundidade (número de linhas) do campo. & A largura (número de colunas) do campo.
    private int depth, width;

    // Matriz que armazena os atores em cada posição
    private Ator[][] field;

    // Matriz que armazena os tipos de terreno
    private Terreno[][] terrenos; 

    /**
     * Cria um campo com as dimensões e a configuração de terreno fornecidas.
     * * @param depth A profundidade do campo.
     * @param width A largura do campo.
     * @param terrenos A matriz de terrenos COMPARTILHADA que este campo usará
     * para verificar a habitabilidade das posições.
     */
    public Field(int depth, int width, Terreno[][] terrenos)
    {
        this.depth = depth;
        this.width = width;
        this.field = new Ator[depth][width];
        this.terrenos = terrenos;
    }
    
    /**
     * Esvazia o campo.
     */
    public void clear()
    {
        for(int row = 0; row < depth; row++) {
            for(int col = 0; col < width; col++) {
                field[row][col] = null;
            }
        }
    }
    
    /**
     * Posiciona um ator na localização fornecida usando coordenadas.
     * Se já houver um ator no local, ele será sobrescrito (perdido).
     * * @param ator O ator a ser posicionado.
     * @param row Coordenada da linha.
     * @param col Coordenada da coluna.
     */
    public void place(Ator ator, int row, int col)
    {
        place(ator, new Location(row, col));
    }
    
    /**
     * Posiciona um ator na localização fornecida.
     * Se já houver um ator no local, ele será sobrescrito (perdido).
     * * @param ator O ator a ser posicionado.
     * @param location O objeto Location onde posicionar o ator.
     */
    public void place(Ator ator, Location location)
    {
        field[location.getRow()][location.getCol()] = ator;
    }

    /**
     * Retorna o ator na localização fornecida, se houver.
     * * @param location O objeto Location a ser verificado.
     * @return O ator na localização, ou {@code null} se estiver vazia.
     */
    public Ator getObjectAt(Location location)
    {
        return getObjectAt(location.getRow(), location.getCol());
    }
    
    /**
     * Retorna o ator na localização fornecida por coordenadas.
     * * @param row A linha desejada.
     * @param col A coluna desejada.
     * @return O ator na localização, ou {@code null} se estiver vazia.
     */
    public Ator getObjectAt(int row, int col)
    {
        return field[row][col];
    }

    /**
     * Retorna o tipo de terreno na localização fornecida.
     * * @param location O objeto Location a ser verificado.
     * @return O objeto {@code Terreno} naquela localização.
     */
    public Terreno getTerrenoAt(Location location)
    {
        return getTerrenoAt(location.getRow(), location.getCol());
    }
    
    /**
     * Retorna o tipo de terreno na localização fornecida por coordenadas.
     * * @param row A linha desejada.
     * @param col A coluna desejada.
     * @return O objeto {@code Terreno} naquela localização.
     */
    public Terreno getTerrenoAt(int row, int col)
    {
        return terrenos[row][col];
    }

    /**
     * Gera uma localização aleatória adjacente à localização fornecida,
     * ou retorna a própria localização.
     * A localização retornada estará sempre dentro dos limites válidos do campo.
     * * @param location A localização base para gerar a adjacência.
     * @return Uma localização válida dentro da área da grade.
     */
    public Location randomAdjacentLocation(Location location)
    {
        int row = location.getRow();
        int col = location.getCol();
        // Gera um deslocamento de -1, 0, ou +1 para linha e coluna.
        int nextRow = row + rand.nextInt(3) - 1;
        int nextCol = col + rand.nextInt(3) - 1;
        // Verifica se a nova localização está fora dos limites.
        if(nextRow < 0 || nextRow >= depth || nextCol < 0 || nextCol >= width) {
            return location;
        }
        else if(nextRow != row || nextCol != col) {
            return new Location(nextRow, nextCol);
        }
        else {
            return location;
        }
    }
    
    /**
     * Tenta encontrar uma localização livre adjacente à localização fornecida.
     * Se não houver nenhuma livre, verifica se a própria localização atual está livre.
     * * @param location A localização base para busca.
     * @return Uma localização válida e livre, ou {@code null} se todas as 
     * localizações adjacentes e a atual estiverem ocupadas.
     */
    public Location freeAdjacentLocation(Location location)
    {
        Iterator adjacent = adjacentLocations(location);
        while(adjacent.hasNext()) {
            Location next = (Location) adjacent.next();
            if(field[next.getRow()][next.getCol()] == null) {
                return next;
            }
        }
        //Verifica se a localização atual está livre
        if(field[location.getRow()][location.getCol()] == null) {
            return location;
        } 
        else {
            return null;
        }
    }

    /**
     * Tenta encontrar uma localização adjacente que seja livre (sem ator)
     * E habitável pelo ator fornecido (de acordo com o terreno).
     * * @param location A localização base para busca.
     * @param ator O ator que deseja se mover (usado para verificar habitabilidade do terreno).
     * @return Uma localização válida, livre e habitável, ou {@code null} se nenhuma for encontrada.
     */
    public Location freeHabitableAdjacentLocation(Location location, Ator ator)
    {
        Iterator adjacent = adjacentLocations(location);
        while(adjacent.hasNext()) {
            Location next = (Location) adjacent.next();
            
            // Verifica se está vazio na camada de atores
            boolean estaVazio = (field[next.getRow()][next.getCol()] == null);
            // Verifica se é habitável na camada de terrenos
            boolean ehHabitavel = getTerrenoAt(next).ehHabitavel(ator);
            
            if(estaVazio && ehHabitavel) {
                return next;
            }
        }
        
        // Não achou local adjacente. Verifica o local atual.
        boolean estaVazio = (field[location.getRow()][location.getCol()] == null);
        boolean ehHabitavel = getTerrenoAt(location).ehHabitavel(ator);
        
        if(estaVazio && ehHabitavel) {
            return location;
        } 
        else {
            return null; // Nenhum local livre e habitável foi encontrado
        }
    }

    /**
     * Gera um iterador sobre uma lista embaralhada de localizações adjacentes
     * à fornecida. A lista não inclui a própria localização.
     * Todas as localizações retornadas estarão dentro dos limites da grade.
     * * @param location A localização da qual gerar adjacências.
     * @return Um iterador sobre localizações adjacentes válidas.
     */
    public Iterator adjacentLocations(Location location)
    {
        int row = location.getRow();
        int col = location.getCol();
        LinkedList locations = new LinkedList();
        for(int roffset = -1; roffset <= 1; roffset++) {
            int nextRow = row + roffset;
            if(nextRow >= 0 && nextRow < depth) {
                for(int coffset = -1; coffset <= 1; coffset++) {
                    int nextCol = col + coffset;
                    // Exclude invalid locations and the original location.
                    if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                        locations.add(new Location(nextRow, nextCol));
                    }
                }
            }
        }
        Collections.shuffle(locations,rand);
        return locations.iterator();
    }

    /**
     * Retorna a profundidade do campo.
     * @return A profundidade (número de linhas).
     */
    public int getDepth()
    {
        return depth;
    }
    
    /**
     * Retorna a largura do campo.
     * @return A largura (número de colunas).
     */
    public int getWidth()
    {
        return width;
    }
}

import java.util.HashMap;
import java.util.Iterator;

/**
 * Esta classe coleta e fornece dados estatísticos sobre o estado do campo.
 * Ela é flexível: cria e mantém um contador para qualquer classe de objeto 
 * que seja encontrada dentro do campo durante a simulação.
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-23
 */
public class FieldStats
{
    // Contadores para cada tipo de entidade (raposa, coelho, etc.) na simulação.
    private HashMap counters;
    // Indica se os contadores estão atualmente atualizados com o estado do campo.
    private boolean countsValid;

    /**
     * Constrói um objeto de estatísticas do campo.
     * Inicializa o mapa de contadores.
     */
    public FieldStats()
    {
        // Configura uma coleção para contadores de cada tipo de ator que possamos encontrar
        counters = new HashMap();
        countsValid = true;
    }

    /**
     * Retorna uma string descrevendo o estado atual da população no campo.
     * Se as estatísticas não estiverem atualizadas, este método força uma nova contagem.
     * * @param field O campo a ser analisado.
     * @return Uma string listando cada espécie e sua contagem atual (ex: "Fox: 10 Rabbit: 50").
     */
    public String getPopulationDetails(Field field)
    {
        StringBuffer buffer = new StringBuffer();
        if(!countsValid) {
            generateCounts(field);
        }
        Iterator keys = counters.keySet().iterator();
        while(keys.hasNext()) {
            Counter info = (Counter) counters.get(keys.next());
            buffer.append(info.getName());
            buffer.append(": ");
            buffer.append(info.getCount());
            buffer.append(' ');
        }
        return buffer.toString();
    }
    
    /**
     * Invalida o conjunto atual de estatísticas e reseta todas as contagens para zero.
     * Deve ser chamado antes de iniciar uma nova varredura de contagem no campo.
     */
    public void reset()
    {
        countsValid = false;
        Iterator keys = counters.keySet().iterator();
        while(keys.hasNext()) {
            Counter cnt = (Counter) counters.get(keys.next());
            cnt.reset();
        }
    }

    /**
     * Incrementa a contagem para uma classe específica de ator.
     * Se a classe ainda não tiver um contador registrado, um novo será criado.
     * * @param atorClass A classe do ator a ser contado (ex: Fox.class).
     */
    public void incrementCount(Class atorClass)
    {
        Counter cnt = (Counter) counters.get(atorClass);
        if(cnt == null) {
            // Ainda não temos um contador para esta espécie - cria um
            cnt = new Counter(atorClass.getName());
            counters.put(atorClass, cnt);
        }
        cnt.increment();
    }

    /**
     * Indica que uma contagem de atores foi concluída.
     * Marca as estatísticas atuais como válidas.
     */
    public void countFinished()
    {
        countsValid = true;
    }

    /**
     * Determina se a simulação ainda é viável (se deve continuar a rodar).
     * A simulação é considerada viável se houver mais de uma espécie viva 
     * (contagem > 0) no campo.
     * * @param field O campo a ser verificado.
     * @return true se houver mais de uma espécie viva, false caso contrário.
     */
    public boolean isViable(Field field)
    {
        // Quantos contadores não são zero.
        int nonZero = 0;
        if(!countsValid) {
            generateCounts(field);
        }
        Iterator keys = counters.keySet().iterator();
        while(keys.hasNext()) {
            Counter info = (Counter) counters.get(keys.next());
            if(info.getCount() > 0) {
                nonZero++;
            }
        }
        return nonZero > 1;
    }
    
    /**
     * Gera as contagens do número de raposas, coelhos e outros atores.
     * Itera por todo o campo verificando o tipo de ator em cada posição.
     * Estas contagens não são mantidas atualizadas automaticamente a cada movimento,
     * mas sim geradas sob demanda quando as informações são solicitadas.
     * * @param field O campo a ser analisado.
     */
    private void generateCounts(Field field)
    {
        reset();
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                //Alterando da classe Object para Ator
                Ator ator = field.getObjectAt(row, col);
                if(ator != null) {
                    incrementCount(ator.getClass());
                }
            }
        }
        countsValid = true;
    }
}

import java.awt.Color;
import java.util.Iterator;
import java.util.List;

/**
 * Representa uma Flor, um tipo específico de vegetação terrestre na simulação.
 * As flores possuem um ciclo de vida curto e têm a capacidade de se espalhar 
 * (reproduzir) exclusivamente para terrenos do tipo Grama adjacentes e desocupados.
 * * @version 1.0
 */
public class Flor extends Vegetacao
{
    // A idade máxima que a flor pode viver.
    private static final int MAX_AGE = 15;

    // A probabilidade de se espalhar.
    private static final double SPREAD_PROBABILITY = 0.11;

    // A cor da flor.
    private static final Color COR = Color.RED;

    /**
     * Constrói uma nova instância de Flor.
     * A flor nasce com idade zero e está viva.
     */
    public Flor()
    {
        super();
    }

    /**
     * Retorna a cor visual desta planta para a interface gráfica.
     * * @return A cor Vermelha (Color.RED).
     */
    @Override 
    public Color getCor()
    {
        return COR;
    }

    /**
     * Retorna a idade máxima de vida permitida para esta planta.
     * * @return A idade máxima em passos.
     */
    @Override
    protected int getMaxAge()
    {
        return MAX_AGE;
    }

    /**
     * Marca a flor como comida (morta).
     */
    public void setEaten()
    {
        setDead();
    }

    /**
     * Executa a lógica específica de ação (reprodução) da flor.
     * A flor tenta se espalhar para um local adjacente se as condições forem atendidas:
     * 1. O sorteio da probabilidade de espalhamento for favorável.
     * 2. O terreno adjacente for do tipo Grama (verificado no campo atual).
     * 3. O local adjacente estiver vazio (verificado no campo atualizado).
     * * @param currentField O campo atual (usado para verificar o tipo de terreno vizinho).
     * @param updatedField O campo atualizado (usado para verificar ocupação e alocar a nova planta).
     * @param newActors A lista onde a nova planta será adicionada caso nasça.
     */
    @Override
    protected void executarAcao(Field currentField, Field updatedField, List<Ator> newActors)
    {
        if (rand.nextDouble() <= SPREAD_PROBABILITY) {
            Iterator adjacent = currentField.adjacentLocations(location);
            while (adjacent.hasNext()) {
                Location next = (Location) adjacent.next();
                
                // Verifica se o local adjacente é Grama E está vazio
                boolean ehGrama = (currentField.getTerrenoAt(next) instanceof Grama);
                boolean estaVazio = (updatedField.getObjectAt(next) == null);
                
                if (ehGrama && estaVazio) {
                    Flor newPlant = new Flor();
                    newActors.add(newPlant);
                    newPlant.setLocation(next);
                    updatedField.place(newPlant, next);
                    break; // Espalha apenas uma vez
                }
            }
        }
    }
}

import java.awt.Color;
import java.util.Iterator;

/**
 * Modelo de uma raposa na simulação.
 * As raposas envelhecem, movem-se, comem coelhos e morrem.
 * As raposas também podem se reproduzir.
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-11
 */
public class Fox extends Animal
{
    // Características compartilhadas por todas as raposas (campos estáticos).
    
    /** Idade mínima para que a raposa possa se reproduzir. */
    private static final int BREEDING_AGE = 10;
    
    /** Idade máxima que uma raposa pode atingir. */
    private static final int MAX_AGE = 150;
    
    /** Probabilidade de uma raposa se reproduzir em cada passo (0 a 1). */
    private static final double BREEDING_PROBABILITY = 0.09;
    
    /** Número máximo de filhotes em um nascimento. */
    private static final int MAX_LITTER_SIZE = 3;
    
    /** Valor nutritivo de um coelho em passos de vida.
     * Representa quantos passos a raposa pode sobreviver após comer um coelho. */
    private static final int RABBIT_FOOD_VALUE = 8;
    
    /** Cor de representação visual da raposa na simulação. */
    private static final Color COR = Color.BLUE;
    
    // Características individuais (campos de instância).
    
    /** Nível de fome da raposa. Aumenta com cada ação e diminui ao comer um coelho.
     * Quando atinge 0, a raposa morre. */
    private int foodLevel;

    /**
     * Cria uma nova raposa.
     * Uma raposa pode ser criada como recém-nascida (idade zero e bem alimentada)
     * ou com idade aleatória.
     * 
     * @param randomAge {@code true} se a raposa deve ter idade e nível de fome aleatórios.
     *                  {@code false} se deve ser criada como recém-nascida.
     */
    public Fox(boolean randomAge)
    {
        super(randomAge); // Chama o construtor da classe Animal
        if(randomAge) {
            foodLevel = rand.nextInt(RABBIT_FOOD_VALUE);
        }
        else {
            foodLevel = RABBIT_FOOD_VALUE;
        }
    }

    /**
     * Retorna a cor de representação visual desta raposa.
     * 
     * @return {@code Color.BLUE} - a cor padrão das raposas na simulação.
     */
    @Override
    public Color getCor()
    {
        return COR; 
    }
    
    /**
     * Aumenta o nível de fome da raposa em uma unidade.
     * Se o nível de fome atinge zero ou menos, a raposa morre.
     * Este método é chamado automaticamente a cada ação da raposa.
     */
    @Override
    protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }

    /**
     * Determina a próxima localização para a qual a raposa deve se mover.
     * Implementa a estratégia de movimento: primeiro busca comida (coelhos),
     * e se não encontrar, move-se para uma localização adjacente livre e habitável.
     * 
     * @param currentField O campo atual da simulação (campo de leitura).
     * @param updatedField O campo atualizado (para verificar terreno e disponibilidade).
     * @return A localização de movimento (onde há comida ou um local livre),
     *         ou {@code null} se nenhuma localização apropriada for encontrada.
     */
    @Override
    protected Location findMoveLocation(Field currentField, Field updatedField)
    {
        Location foodLocation = findFood(currentField, updatedField);
        if(foodLocation != null) {
            return foodLocation;
        }
        
        return updatedField.freeHabitableAdjacentLocation(location, this);
    }

    /**
     * Retorna a idade máxima que uma raposa pode atingir.
     * 
     * @return A idade máxima ({@value #MAX_AGE} passos).
     */
    @Override
    protected int getMaxAge()
    {
        return MAX_AGE;
    }

    /**
     * Retorna a idade mínima para que uma raposa possa se reproduzir.
     * 
     * @return A idade mínima para reprodução ({@value #BREEDING_AGE} passos).
     */
    @Override
    protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }

    /**
     * Retorna a probabilidade de uma raposa se reproduzir.
     * 
     * @return A probabilidade de reprodução (valor entre 0 e 1: {@value #BREEDING_PROBABILITY}).
     */
    @Override
    protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }

    /**
     * Retorna o número máximo de filhotes em um nascimento.
     * 
     * @return O número máximo de filhotes ({@value #MAX_LITTER_SIZE}).
     */
    @Override
    protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }

    /**
     * Cria um novo filhote de raposa.
     * Este método é chamado durante o processo de reprodução.
     * 
     * @param randomAge {@code true} para criar um filhote com idade aleatória,
     *                  {@code false} para criar um recém-nascido.
     * @return Uma nova instância de {@code Fox}.
     */
    @Override
    protected Animal createNewborn(boolean randomAge)
    {
        return new Fox(randomAge);
    }
    
    // --- Métodos Específicos da Raposa ---

    /**
     * Procura por uma presa (coelho) em uma localização adjacente habitável.
     * Se encontrar um coelho vivo, a raposa o consome, aumentando seu nível de fome.
     * 
     * <p>Este método verifica:</p>
     * <ul>
     *   <li>Se a localização adjacente é habitável para a raposa</li>
     *   <li>Se há um coelho naquela localização</li>
     *   <li>Se o coelho está vivo</li>
     * </ul>
     * 
     * @param currentField O campo atual da simulação (contém os animais).
     * @param updatedField O campo atualizado (contém informações de terreno).
     * @return A localização do coelho encontrado, ou {@code null} se nenhum coelho
     *         habitável e vivo for encontrado nas adjacências.
     */
    private Location findFood(Field currentField, Field updatedField)
    {
        Iterator adjacentLocations = currentField.adjacentLocations(location);
        while(adjacentLocations.hasNext()) {
            Location where = (Location) adjacentLocations.next();

            if (updatedField.getTerrenoAt(where).ehHabitavel(this)) {
                Object animal = currentField.getObjectAt(where);

                if(animal instanceof Rabbit) {
                    Rabbit rabbit = (Rabbit) animal;
                    if(rabbit.isAlive()) { 
                        rabbit.setEaten();
                        foodLevel = RABBIT_FOOD_VALUE;
                        return where;
                    }
                }
            }
        }
        return null;
    }

}

import java.awt.Color;

/**
 * Representa um terreno do tipo Grama na simulação.
 * Este é o terreno padrão e predominante, servindo de habitat para 
 * todos os animais terrestres e permitindo o crescimento de flores.
 * * @version 1.0
 */
public class Grama extends Terreno
{
    private static final Color COR = new Color(34, 139, 34); // Verde escuro

    /**
     * Verifica se um determinado ator pode habitar ou transitar sobre a grama.
     * * @param ator O ator que deseja ocupar este terreno.
     * @return true se o ator for um Animal ou uma Flor, false caso contrário.
     */
    @Override
    public boolean ehHabitavel(Ator ator)
    {
        // Por enquanto, consideramos que todo animal pode andar na grama.
        if (ator instanceof Animal) {
            return true;
        }
        // Quando criarmos a Flor, ela poderá habitar aqui
        else if (ator instanceof Flor) { 
            return true;
        }else{
        return false; // Poderia ser diferente para Plantas
        }
    }
    
    /**
     * Retorna a cor associada a este tipo de terreno para renderização.
     * * @return A cor definida para a grama.
     */
    @Override
    public Color getCor()
    {
        return COR;
    }
}

/**
 * Representa uma localização (coordenada) em uma grade retangular.
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-09
 */
public class Location
{
    // Posição da linha (coordenada vertical).
    private int row;
    // Posição da coluna (coordenada horizontal).
    private int col;

    /**
     * Cria uma nova localização com as coordenadas especificadas.
     * * @param row A coordenada da linha.
     * @param col A coordenada da coluna.
     */
    public Location(int row, int col)
    {
        this.row = row;
        this.col = col;
    }
    
    /**
     * Implementa a igualdade de conteúdo.
     * Verifica se o objeto fornecido é uma localização que representa 
     * as mesmas coordenadas de linha e coluna que este objeto.
     * * @param obj O objeto a ser comparado.
     * @return true se os objetos forem iguais, false caso contrário.
     */
    public boolean equals(Object obj)
    {
        if(obj instanceof Location) {
            Location other = (Location) obj;
            return row == other.getRow() && col == other.getCol();
        }
        else {
            return false;
        }
    }
    
    /**
     * Retorna uma representação textual da localização.
     * O formato é "linha,coluna".
     * * @return Uma string representando a localização.
     */
    public String toString()
    {
        return row + "," + col;
    }
    
    /**
     * Gera um código hash único para esta localização.
     * Usa os 16 bits superiores para o valor da linha e os inferiores para a coluna.
     * Exceto para grades muito grandes, isso deve fornecer um código hash único
     * para cada par (linha, coluna).
     * * @return Um código hash inteiro para a localização.
     */
    public int hashCode()
    {
        return (row << 16) + col;
    }
    
    /**
     * Retorna a coordenada da linha.
     * * @return A linha.
     */
    public int getRow()
    {
        return row;
    }
    
    /**
     * Retorna a coordenada da coluna.
     * * @return A coluna.
     */
    public int getCol()
    {
        return col;
    }
}

import java.awt.Color;

/**
 * Representa um terreno do tipo Pedra na simulação.
 * Este terreno atua como um obstáculo físico intransponível, delimitando áreas
 * e impedindo o movimento de animais ou o crescimento de vegetação.
 * * @version 1.0
 */
public class Pedra extends Terreno
{
    private static final Color COR = Color.GRAY; // Cinza

    /**
     * Verifica se um determinado ator pode habitar ou transitar sobre a pedra.
     * Como pedras são obstáculos sólidos, nenhum ator pode habitá-las.
     * * @param ator O ator que deseja ocupar este terreno.
     * @return false sempre, pois pedras não são habitáveis por ninguém.
     */
    @Override
    public boolean ehHabitavel(Ator ator)
    {
        if (ator instanceof Animal) {
            return false;
        }
        return false;
    }
    
    /**
     * Retorna a cor associada a este tipo de terreno para renderização.
     * * @return A cor definida para a pedra (Cinza).
     */
    @Override
    public Color getCor()
    {
        return COR;
    }
}

import java.awt.Color;
import java.util.List;
import java.util.Iterator; 
import java.util.Random;

/**
 * Modelo simples de um Coelho (presa) na simulação.
 * Os coelhos envelhecem, movem-se aleatoriamente, reproduzem-se e morrem
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-11
 */
public class Rabbit extends Animal
{
    // Características compartilhadas por todos os coelhos (campos estáticos).

    // A idade mínima para que um coelho possa começar a se reproduzir.
    private static final int BREEDING_AGE = 5;

    // A idade máxima que um coelho pode atingir antes de morrer de velhice.
    private static final int MAX_AGE = 50;

    // A probabilidade de um coelho se reproduzir em cada passo.
    private static final double BREEDING_PROBABILITY = 0.10;

    // O número máximo de filhotes que podem nascer em uma única ninhada.
    private static final int MAX_LITTER_SIZE = 5;

    // AA cor de representação visual do coelho na simulação
    private static final Color COR = Color.ORANGE;

    // Valor nutricional de uma flor (quantos passos o coelho ganha)
    private static final int FLOWER_FOOD_VALUE = 8;

    // Nível de fome atual
    private int foodLevel;

    /**
     * Cria um novo coelho.
     * O coelho pode ser criado como recém-nascido (idade zero)
     * ou com uma idade aleatória (para popular a simulação inicial).
     * * @param randomAge true se o coelho deve ter idade aleatória,
     * false se deve ser criado como recém-nascido (idade 0).
     */
    public Rabbit(boolean randomAge)
    {
       super(randomAge);
       if(randomAge) {
           foodLevel = rand.nextInt(FLOWER_FOOD_VALUE);
       } else {
           foodLevel = FLOWER_FOOD_VALUE;
       }
    }

    /**
     * Retorna a cor de representação visual deste coelho.
     * * @return A cor Laranja (Color.ORANGE).
     */
    @Override
    public Color getCor()
    {
        return COR; 
    }
    
    /**
     * Aumenta a fome do animal. Se chegar a zero, o coelho morre.
     */
    @Override
    protected void incrementHunger()
    {
        foodLevel--;
        if(foodLevel <= 0) {
            setDead();
        }
    }

    /**
     * Determina a próxima localização para a qual o coelho deve se mover.
     * Coelhos se movem aleatoriamente para qualquer localização adjacente 
     * que esteja livre (sem outro animal) e seja habitável (terreno permitido).
     * * @param currentField O campo atual (para consulta).
     * @param updatedField O campo atualizado (para verificar disponibilidade).
     * @return Uma localização livre e habitável, ou null se não houver nenhuma.
     */
    @Override
    protected Location findMoveLocation(Field currentField, Field updatedField)
    {
        // 1. Tenta achar comida
        Location foodLocation = findFood(currentField, updatedField);
        if(foodLocation != null) {
            return foodLocation;
        }
        // 2. Se não, procura movimento livre
        return updatedField.freeHabitableAdjacentLocation(location, this);
    }

    /**
     * Retorna a idade máxima de vida do coelho.
     * * @return A idade máxima ({@value #MAX_AGE}).
     */
    @Override
    protected int getMaxAge()
    {
        return MAX_AGE;
    }

    /**
     * Retorna a idade mínima para reprodução.
     * * @return A idade de reprodução ({@value #BREEDING_AGE}).
     */
    @Override
    protected int getBreedingAge()
    {
        return BREEDING_AGE;
    }

    /**
     * Retorna a probabilidade de reprodução.
     * * @return A probabilidade ({@value #BREEDING_PROBABILITY}).
     */
    @Override
    protected double getBreedingProbability()
    {
        return BREEDING_PROBABILITY;
    }

    /**
     * Retorna o tamanho máximo da ninhada.
     * * @return O tamanho máximo ({@value #MAX_LITTER_SIZE}).
     */
    @Override
    protected int getMaxLitterSize()
    {
        return MAX_LITTER_SIZE;
    }

    /**
     * Cria um novo filhote de coelho.
     * * @param randomAge se o filhote deve ter idade aleatória (geralmente false).
     * @return Um novo objeto Rabbit.
     */
    @Override
    protected Animal createNewborn(boolean randomAge)
    {
        return new Rabbit(randomAge);
    }

    /**
     * Marca o coelho como morto por ter sido caçado.
     * Este método é chamado quando uma raposa "come" este coelho.
     */
    public void setEaten()
    {
       setDead(); // Usa o método protegido da classe Animal
    }

    /**
     * Procura por flores adjacentes para comer.
     * Se encontrar uma flor viva, o coelho a come (a flor morre)
     * e o nível de fome do coelho é restaurado.
     * * @param currentField O campo atual (para consulta).
     * @param updatedField O campo atualizado (para verificar disponibilidade).
     * @return A localização da flor comida, ou null se nenhuma flor for encontrada.
     */
    private Location findFood(Field currentField, Field updatedField)
    {
        Iterator adjacentLocations = currentField.adjacentLocations(location);
        while(adjacentLocations.hasNext()) {
            Location where = (Location) adjacentLocations.next();

            // Verifica se o coelho pode ir para lá (habitável)
            if (updatedField.getTerrenoAt(where).ehHabitavel(this)) {
                Object actor = currentField.getObjectAt(where);

                if(actor instanceof Flor) {
                    Flor flor = (Flor) actor;
                    if(flor.isAlive()) { 
                        flor.setEaten(); // Come a flor
                        foodLevel = FLOWER_FOOD_VALUE; // Enche a barriga
                        return where;
                    }
                }
            }
        }
        return null;
    }
}

import java.util.Random;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Collections;
import java.awt.event.ActionEvent;   
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;


import javax.swing.Timer;

/**
 * Classe principal do simulador predador-presa.
 * Gerencia o ciclo de vida da simulação, incluindo o controle de tempo,
 * a gestão das listas de atores (animais e plantas), a manipulação dos campos (atual e atualizado)
 * e a coordenação com a interface gráfica.
 * * Esta classe atua como o controlador central, orquestrando a interação entre
 * o modelo (Atores, Field) e a visão (SimulatorView).
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-09
 */
public class Simulator
{
    // Constantes de configuração da simulação.

    // Largura padrão para a grade de simulação.
    private static final int DEFAULT_WIDTH = 50;

    // Profundidade (altura) padrão para a grade de simulação.
    private static final int DEFAULT_DEPTH = 50;

    // Probabilidade de uma raposa ser criada em qualquer posição da grade na inicialização.
    private static final double FOX_CREATION_PROBABILITY = 0.02;

    // Probabilidade de um coelho ser criado em qualquer posição da grade na inicialização.
    private static final double RABBIT_CREATION_PROBABILITY = 0.08; 

    // Probabilidade de uma flor ser criada em um terreno de grama na inicialização (15%)
    private static final double FLOR_CREATION_PROBABILITY = 0.15; 

    // Probabilidade de uma vitória-régia ser criada em um terreno de água na inicialização (10%)
    private static final double VITORIAREGIA_CREATION_PROBABILITY = 0.10;
    
    // Dimensões do campo de simulação.
    private int depth;
    private int width;

    // Lista de todos os atores (animais e plantas) atualmente vivos no campo.
    private List<Ator> atores;

    // Lista temporária para armazenar atores recém-nascidos durante um passo de simulação.
    private List<Ator> newAtores;

    // O estado atual do campo.
    private Field field;

    // Um segundo campo usado como buffer para construir o próximo estado da simulação.
    private Field updatedField;

    // O contador de passos (iterações) da simulação atual.
    private int step;

    // A interface gráfica que exibe a simulação.
    private SimulatorView view;

    // Timer responsável por executar os passos da simulação periodicamente.
    private Timer timer;

    // Intervalo de tempo em milissegundos entre cada passo da simulação
    private static final int TIMER_DELAY_MS = 200;

    // Matriz única que armazena a configuração do terreno
    private Terreno[][] terrenos;

    // O tipo de terreno padrão utilizado na inicialização (Grama).
    private static final Terreno TERRENO_PADRAO = new Grama();

    // Mapeamento entre IDs numéricos (do arquivo de mapa) e objetos Terreno correspondentes.
    private static final HashMap<Integer, Terreno> TERRENO_MAP = new HashMap<>();
    static {
        TERRENO_MAP.put(0, new Grama());
        TERRENO_MAP.put(1, new Agua());
        TERRENO_MAP.put(2, new Pedra());
    }
    
    /**
     * Constrói um simulador com o tamanho padrão.
     * Inicializa a grade com as dimensões definidas em DEFAULT_DEPTH e DEFAULT_WIDTH.
     */
    public Simulator()
    {
        this(DEFAULT_DEPTH, DEFAULT_WIDTH);
    }
    
    /**
     * Cria um simulador com as dimensões especificadas.
     * Inicializa as estruturas de dados, carrega o terreno, cria a interface gráfica
     * e configura o timer de execução.
     * * @param depth A profundidade (altura) do campo. Deve ser maior que zero.
     * @param width A largura do campo. Deve ser maior que zero.
     */
    public Simulator(int depth, int width)
    {
        if(width <= 0 || depth <= 0) {
            System.out.println("The dimensions must be greater than zero.");
            System.out.println("Using default values.");
            depth = DEFAULT_DEPTH;
            width = DEFAULT_WIDTH;
        }

        this.depth = depth;
        this.width = width;

        // 1. Cria a matriz de terrenos que será compartilhada
        terrenos = new Terreno[depth][width];
        initializeTerrenos(); // Inicializa com o padrão

        // 2. Cria as listas de atores
        atores = new ArrayList<Ator>();
        newAtores = new ArrayList<Ator>();

        // 3. Cria os DOIS campos, passando a MESMA matriz de terrenos
        field = new Field(depth, width, terrenos);
        updatedField = new Field(depth, width, terrenos);

        // 4. Configura a GUI e o Timer
        view = new SimulatorView(this, depth, width);
        timer = new Timer(TIMER_DELAY_MS, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                simulateOneStep();
            }
        });
        
        // Prepara o estado inicial válido.
        reset();
    }
    

    /**
     * Inicia ou retoma a execução automática da simulação.
     * O timer começará a disparar eventos que chamam simulateOneStep.
     */
    public void startSimulation()
    {
        timer.start();
    }
    
    /**
     * Pausa a execução automática da simulação.
     * O timer é interrompido, congelando o estado atual.
     */
    public void stopSimulation()
    {
        timer.stop();
    }

    /**
     * Reinicia a simulação para o estado inicial.
     * Para o timer, recarrega o mapa, repopula o campo e atualiza a visualização.
     */
    public void resetSimulation()
    {
        timer.stop(); // Para o timer
        reset();      // Chama o reset lógico
        // Atualiza a view para mostrar o estado resetado
        view.showStatus(step, field); 
    }

    
    /**
     * Executa um único passo da simulação.
     * Percorre todos os atores vivos, permitindo que ajam (mover, comer, reproduzir).
     * Remove atores mortos e adiciona novos nascimentos.
     * Ao final, troca os buffers de campo (field e updatedField) e atualiza a tela.
     */
    public void simulateOneStep()
    {
        step++;
        newAtores.clear();
        
        // Permite que todos os atores ajam
        for(Iterator<Ator> iter = atores.iterator(); iter.hasNext(); ) {
            Ator ator = iter.next();
            if(ator.isAlive()) {
                ator.acao(field, updatedField, newAtores);
            }else {
                iter.remove();   
            }
        }
        // Adiciona animais recém-nascidos à lista principal
        atores.addAll(newAtores);
        
        // Troca o campo e o updatedField para o próximo passo
        Field temp = field;
        field = updatedField;
        updatedField = temp;
        updatedField.clear();

        // Exibe o novo campo na tela
        view.showStatus(step, field);
    }
        
    /**
     * Reseta a simulação para uma posição inicial.
     * Limpa os atores, recarrega o terreno do arquivo e popula o campo aleatoriamente.
     */
    public void reset()
    {
        step = 0;
        atores.clear();
        field.clear();
        updatedField.clear();
        loadTerrenoFromFile("mapa.txt");
        populate(field);
        
    }
    
    /**
     * Popula o campo com raposas, coelhos e vegetação.
     * A criação de cada ator depende das probabilidades definidas e da
     * compatibilidade com o terreno da posição (ex: Vitória-Régia apenas na água).
     * * @param field O campo a ser populado.
     */
    private void populate(Field field)
    {
        Random rand = new Random();
        field.clear(); // Limpa apenas os atores, não o terreno
        
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {

                
                // --- LÓGICA DOS ANIMAIS ---
                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                    Fox fox = new Fox(true);
                    // Só coloca a raposa se o terreno for habitável por ela
                    placeIfHabitable(field, fox, row, col);
                }
                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                    Rabbit rabbit = new Rabbit(true);
                    // Só coloca o coelho se o terreno for habitável por ele
                    placeIfHabitable(field, rabbit, row, col);
                }
                                
                // Se o local ainda estiver vazio (nenhum animal foi criado nele)...
                if (field.getObjectAt(row, col) == null) {
                    
                    // Tentamos plantar uma Flor.
                    if (rand.nextDouble() <= FLOR_CREATION_PROBABILITY) {
                        Flor flor = new Flor();
                        placeIfHabitable(field, flor, row, col);
                    }
                    
                    // Tentamos plantar uma VitoriaRegia.
                    if (rand.nextDouble() <= VITORIAREGIA_CREATION_PROBABILITY) {
                        VitoriaRegia vixRegia = new VitoriaRegia();
                        placeIfHabitable(field, vixRegia, row, col);
                    }
                }
                // --- FIM DA LÓGICA DAS PLANTAS ---
            }
        }
        Collections.shuffle(atores);
    }

    /**
     * Inicializa a matriz de terrenos preenchendo todas as posições com o terreno padrão (Grama).
     */
    private void initializeTerrenos()
    {
        for (int row = 0; row < depth; row++) {
            for (int col = 0; col < width; col++) {
                terrenos[row][col] = TERRENO_PADRAO;
            }
        }
    }

    /**
     * Tenta colocar um ator numa posição do campo se o terreno for habitável
     * e a posição estiver vazia. Centraliza a lógica de adição para evitar
     * duplicação em `populate()`.
     *
     * @param field O campo onde colocar o ator.
     * @param ator O ator a ser colocado (Animal ou Vegetacao).
     * @param row A coordenada da linha.
     * @param col A coordenada da coluna.
     */
    private void placeIfHabitable(Field field, Ator ator, int row, int col)
    {
        Terreno terreno = field.getTerrenoAt(row, col);
        if (terreno.ehHabitavel(ator) && field.getObjectAt(row, col) == null) {
            atores.add(ator);
            ator.setLocation(new Location(row, col));
            field.place(ator, row, col);
        }
    }

    /**
     * Carrega a configuração do terreno a partir de um arquivo de texto.
     * O arquivo deve conter números inteiros separados por espaço, onde cada número
     * corresponde a um tipo de terreno (0=Grama, 1=Água, 2=Pedra).
     * Se o arquivo não for encontrado ou contiver erros, o terreno padrão é mantido.
     * * @param fileName O caminho ou nome do arquivo de mapa (ex: "mapa.txt").
     */
    public void loadTerrenoFromFile(String fileName)
    {
        // Reseta o terreno para o padrão primeiro
        initializeTerrenos(); 
        
        File file = new File(fileName);

        // Usando "try-with-resources" para garantir que o 'br' será fechado automaticamente.
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            
            String linha;
            int row = 0;
            
            // Lê uma linha do arquivo 
            // Continua enquanto a linha não for nula e não passamos da altura do mapa
            while ((linha = br.readLine()) != null && row < depth) {
                
                // Quebra a linha em várias strings, usando " " como separador 
                String[] campos = linha.trim().split(" ");
                
                for (int col = 0; col < width && col < campos.length; col++) {
                    try {
                        // Converte o texto para um inteiro 
                        int terrenoID = Integer.parseInt(campos[col]);
                        Terreno terreno = TERRENO_MAP.get(terrenoID);
                        
                        if (terreno != null) {
                            terrenos[row][col] = terreno;
                        }
                    } catch (NumberFormatException e) {
                        // Se o texto no arquivo não for um número válido,
                        // apenas ignoramos e mantemos o terreno padrão (Grama).
                        System.err.println("Formato inválido no mapa em " + row + "," + col);
                    }
                }
                row++;
            }
        } catch (FileNotFoundException e) {
            System.err.println("Arquivo do mapa não encontrado: " + fileName);
            System.err.println("Usando terreno padrão (Grama).");
        } catch (IOException e) {
            System.err.println("Erro ao ler o arquivo do mapa: " + e.getMessage());
            System.err.println("Usando terreno padrão (Grama).");
        }
    }
}

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

/**
 * Uma visualização gráfica da grade de simulação.
 * A visão exibe um retângulo colorido para cada localização representando seu conteúdo.
 * Ela utiliza cores específicas definidas pelos próprios atores e terrenos.
 * * Além da grade, esta classe gerencia os controles da simulação (botões) e
 * exibe as estatísticas populacionais e o contador de passos.
 * 
 * @author David J. Barnes and Michael Kolling
 * @version 2002-04-23
 */
public class SimulatorView extends JFrame
{
    private final String STEP_PREFIX = "Step: ";
    private final String POPULATION_PREFIX = "Population: ";
    private JLabel stepLabel, population;
    private FieldView fieldView;
    
    // Objeto de estatísticas para computar e armazenar informações da simulação.
    private FieldStats stats;

    // Referência ao controlador da simulação para vincular os botões de ação.
    private Simulator simulator;

    /**
     * Cria uma visualização com a largura e altura fornecidas.
     * Inicializa a interface gráfica, incluindo o painel do campo, 
     * rótulos de estatísticas e botões de controle.
     * * @param simulator A instância do simulador que controla a lógica.
     * @param height A altura (profundidade) da grade de simulação.
     * @param width A largura da grade de simulação.
     */
    public SimulatorView(Simulator simulator, int height, int width)
    {
        this.simulator = simulator;
        stats = new FieldStats();

        setTitle("Zoofilia, ecossitema fudido");
        stepLabel = new JLabel(STEP_PREFIX, JLabel.CENTER);
        population = new JLabel(POPULATION_PREFIX, JLabel.CENTER);
        
        setLocation(100, 50);
        
        fieldView = new FieldView(height, width);

        // Configuração do painel de botões
        JPanel buttonPanel = new JPanel();
        
        JButton startButton = new JButton("Iniciar");
        startButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                simulator.startSimulation();
            }
        });
        buttonPanel.add(startButton);
        
        JButton stopButton = new JButton("Pausar");
        stopButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                simulator.stopSimulation();
            }
        });
        buttonPanel.add(stopButton);
        
        JButton resetButton = new JButton("Resetar");
        resetButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                simulator.resetSimulation();
            }
        });
        buttonPanel.add(resetButton);

        // Organização dos componentes na janela
        Container contents = getContentPane();
        contents.add(stepLabel, BorderLayout.NORTH);
        contents.add(fieldView, BorderLayout.CENTER);
        
        JPanel southPanel = new JPanel(new BorderLayout());
        southPanel.add(population, BorderLayout.CENTER);
        southPanel.add(buttonPanel, BorderLayout.SOUTH);
        contents.add(southPanel, BorderLayout.SOUTH);

        pack();
        setVisible(true);
    }
    

    /**
     * Exibe o estado atual do campo na interface gráfica.
     * Atualiza o contador de passos, redesenha a grade (terrenos e atores)
     * e atualiza as estatísticas populacionais.
     * * @param step O passo atual da iteração.
     * @param field O campo contendo o estado atual a ser representado.
     */
    public void showStatus(int step, Field field)
    {
        if(!isVisible())
            setVisible(true);

        stepLabel.setText(STEP_PREFIX + step);

        stats.reset();
        fieldView.preparePaint();
            
        for(int row = 0; row < field.getDepth(); row++) {
            for(int col = 0; col < field.getWidth(); col++) {
                
                // 1. Desenha o Terreno (fundo)
                Terreno terreno = field.getTerrenoAt(row, col);
                fieldView.drawMark(col, row, terreno.getCor());
                
                // 2. Desenha o Ator (frente), se houver
                Ator ator = field.getObjectAt(row, col);
                if(ator != null) {
                    stats.incrementCount(ator.getClass());
                    fieldView.drawMark(col, row, ator.getCor());
                }
                // Se o ator for null, o terreno que desenhamos no passo 1 já é o correto
                // (Não precisamos mais do EMPTY_COLOR)
            }
        }
        stats.countFinished();

        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
        fieldView.repaint();
    }
  
    /**
     * Determina se a simulação ainda é viável e deve continuar.
     * * @param field O campo a ser verificado.
     * @return true se houver mais de uma espécie viva, false caso contrário.
     */
    public boolean isViable(Field field)
    {
        return stats.isViable(field);
    }
    
    /**
     * Fornece uma visualização gráfica de um campo retangular.
     * Esta é uma classe interna aninhada que define um componente personalizado
     * para a interface do usuário. Este componente exibe o campo.
     */
    private class FieldView extends JPanel
    {
        private final int GRID_VIEW_SCALING_FACTOR = 6;

        private int gridWidth, gridHeight;
        private int xScale, yScale;
        Dimension size;
        private Graphics g;
        private Image fieldImage;

        /**
         * Cria um novo componente FieldView.
         * * @param height A altura da grade.
         * @param width A largura da grade.
         */
        public FieldView(int height, int width)
        {
            gridHeight = height;
            gridWidth = width;
            size = new Dimension(0, 0);
        }

        /**
         * Informa ao gerenciador de GUI qual o tamanho preferido para este componente.
         * * @return A dimensão preferida (largura x altura).
         */
        public Dimension getPreferredSize()
        {
            return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR,
                                 gridHeight * GRID_VIEW_SCALING_FACTOR);
        }
        
        /**
         * Prepara o componente para uma nova rodada de pintura.
         * Se o componente foi redimensionado, recalcula o fator de escala.
         */
        public void preparePaint()
        {
            if(! size.equals(getSize())) {  // if the size has changed...
                size = getSize();
                fieldImage = fieldView.createImage(size.width, size.height);
                g = fieldImage.getGraphics();

                xScale = size.width / gridWidth;
                if(xScale < 1) {
                    xScale = GRID_VIEW_SCALING_FACTOR;
                }
                yScale = size.height / gridHeight;
                if(yScale < 1) {
                    yScale = GRID_VIEW_SCALING_FACTOR;
                }
            }
        }
        
        /**
         * Pinta uma marca na localização da grade neste campo, usando a cor fornecida.
         * * @param x A coordenada x (coluna) da grade.
         * @param y A coordenada y (linha) da grade.
         * @param color A cor a ser usada para o desenho.
         */
        public void drawMark(int x, int y, Color color)
        {
            g.setColor(color);
            g.fillRect(x * xScale, y * yScale, xScale-1, yScale-1);
        }

        /**
         * O componente de visualização do campo precisa ser redesenhado.
         * Copia a imagem interna para a tela.
         * * @param g O contexto gráfico.
         */
        public void paintComponent(Graphics g)
        {
            if(fieldImage != null) {
                g.drawImage(fieldImage, 0, 0, null);
            }
        }
    }
}

import java.awt.Color;

/**
 * Classe base abstrata que representa um tipo de terreno na simulação.
 * O terreno forma a camada estática do campo, definindo as regras de movimentação
 * e habitação para os atores (animais e plantas), além da aparência visual do ambiente.
 * * @version 1.0
 */
public abstract class Terreno
{
    /**
     * Verifica se um determinado Ator pode habitar este terreno.
     * @param ator O Ator a ser verificado.
     * @return true se o ator pode habitar, false caso contrário.
     */
    public abstract boolean ehHabitavel(Ator ator);
    
    /**
     * Retorna a cor deste terreno para a renderização na GUI.
     * @return A cor do terreno.
     */
    public abstract Color getCor();
}

import java.awt.Color;
import java.util.List;
import java.util.Random;

/**
 * Classe base abstrata para todos os tipos de vegetação na simulação.
 * Esta classe implementa a interface Ator e gerencia a lógica comum do ciclo de vida
 * das plantas, como envelhecimento, estado de vida e localização.
 * * Diferente dos animais, a vegetação não se move, mas pode se espalhar (reproduzir)
 * para terrenos adjacentes compatíveis.
 * * @version 1.0
 */
public abstract class Vegetacao implements Ator
{
    // O gerador de números aleatórios compartilhado.
    protected static final Random rand = new Random();
    
    // A idade atual da planta em passos da simulação
    protected int age;

    // Indica se a planta está viva ou morta.
    protected boolean alive;

    // A localização atual da planta no campo.
    protected Location location;

    /**
     * Cria uma nova planta.
     * Inicializa a idade como zero e o estado como vivo.
     */
    public Vegetacao()
    {
        this.age = 0;
        this.alive = true;
    }

    /**
     * Executa as ações da vegetação durante um passo da simulação.
     * O ciclo de vida padrão definido aqui é:
     * 1. A planta envelhece.
     * 2. Se estiver viva, tenta executar sua ação específica (geralmente espalhar-se).
     * 3. Se ainda estiver viva após a ação, ela é mantida na mesma localização no campo atualizado.
     * * @param currentField O campo atual contendo o estado atual da simulação.
     * @param updatedField O campo onde o novo estado está sendo construído.
     * @param newActors Lista onde novas plantas criadas são adicionadas.
     */
    @Override
    public void acao(Field currentField, Field updatedField, List<Ator> newActors)
    {
        incrementAge();
        if (isAlive()) {
            executarAcao(currentField, updatedField, newActors);
            
            // Se a planta não foi "comida" ou destruída na sua ação,
            // ela permanece no local no campo atualizado.
            if (isAlive()) {
                updatedField.place(this, location);
            }
        }
    }

    /**
     * Aumenta a idade da planta em uma unidade.
     * Se a idade atingir o limite máximo da espécie, a planta morre naturalmente.
     */
    private void incrementAge()
    {
        age++;
        if(age > getMaxAge()) {
            setDead();
        }
    }

    /**
     * Verifica se a planta ainda está viva.
     * * @return true se a planta está viva, false caso contrário.
     */
    @Override
    public boolean isAlive()
    {
        return alive;
    }

    /**
     * Define a localização da planta no campo.
     * * @param location A nova localização (objeto Location).
     */
    @Override
    public void setLocation(Location location)
    {
        this.location = location;
    }

    /**
     * Define a localização da planta no campo usando coordenadas.
     * Método utilitário para facilitar a definição de posição.
     * * @param row A linha da localização.
     * @param col A coluna da localização.
     */
    public void setLocation(int row, int col)
    {
        this.location = new Location(row, col);
    }

    /**
     * Define o estado da planta como morta.
     * A planta será removida da simulação no próximo ciclo.
     */
    protected void setDead()
    {
        alive = false;
    }

    // --- MÉTODOS ABSTRATOS (para subclasses) ---

    /**
     * Retorna a idade máxima que este tipo de planta pode viver.
     * * @return A idade máxima em passos.
     */
    protected abstract int getMaxAge();
    
    /**
     * Define a cor desta planta para a GUI.
     * @return A cor da planta.
     */
    public abstract Color getCor();

    /**
     * Executa a lógica específica desta planta.
     * Geralmente envolve a tentativa de se espalhar para locais adjacentes
     * compatíveis com o tipo da planta.
     * * @param currentField O campo atual (para verificar arredores).
     * @param updatedField O campo atualizado (para alocar novas plantas).
     * @param newActors Lista para adicionar novas plantas geradas.
     */
    protected abstract void executarAcao(Field currentField, Field updatedField, List<Ator> newActors);
}

import java.awt.Color;
import java.util.Iterator;
import java.util.List;

/**
 * Representa uma Vitória-Régia, um tipo específico de vegetação aquática na simulação.
 * Estas plantas habitam exclusivamente terrenos do tipo Água e possuem a capacidade
 * de se espalhar (reproduzir) para locais aquáticos adjacentes que estejam desocupados.
 * * @version 1.0
 */
public class VitoriaRegia extends Vegetacao
{
    // A idade máxima que uma vitória-régia pode atingir em passos da simulação antes de morrer.
    private static final int MAX_AGE = 20;

    // A probabilidade de uma vitória-régia gerar uma nova planta em um local adjacente a cada passo.
    private static final double SPREAD_PROBABILITY = 0.05;

    // A cor da vitória-régia para representação visual na simulação.
    private static final Color COR = Color.MAGENTA;

    /**
     * Constrói uma nova instância de Vitória-Régia.
     * A planta nasce com idade zero e está viva.
     */
    public VitoriaRegia()
    {
        super();
    }

    /**
     * Retorna a cor visual desta planta para a interface gráfica.
     * * @return A cor Magenta (Color.MAGENTA).
     */
    @Override 
    public Color getCor()
    {
        return COR;
    }

    /**
     * Retorna a idade máxima de vida permitida para esta planta aquática.
     * * @return A idade máxima em passos.
     */
    @Override
    protected int getMaxAge()
    {
        return MAX_AGE;
    }

    /**
     * Executa a lógica específica de ação (reprodução) da vitória-régia.
     * A planta tenta se espalhar para um local adjacente se as condições forem atendidas:
     * 1. O sorteio da probabilidade de espalhamento for favorável.
     * 2. O terreno adjacente for do tipo Água (verificado no campo atual).
     * 3. O local adjacente estiver vazio (verificado no campo atualizado).
     * * @param currentField O campo atual (usado para verificar o tipo de terreno vizinho).
     * @param updatedField O campo atualizado (usado para verificar ocupação e alocar a nova planta).
     * @param newActors A lista onde a nova planta será adicionada caso nasça.
     */
    @Override
    protected void executarAcao(Field currentField, Field updatedField, List<Ator> newActors)
    {
        if (rand.nextDouble() <= SPREAD_PROBABILITY) {
            Iterator adjacent = currentField.adjacentLocations(location);
            while (adjacent.hasNext()) {
                Location next = (Location) adjacent.next();
                
                // Verifica se o local adjacente é Água E está vazio
                boolean ehAgua = (currentField.getTerrenoAt(next) instanceof Agua);
                boolean estaVazio = (updatedField.getObjectAt(next) == null);
                
                if (ehAgua && estaVazio) {
                    VitoriaRegia newPlant = new VitoriaRegia();
                    newActors.add(newPlant);
                    newPlant.setLocation(next);
                    updatedField.place(newPlant, next);
                    break; // Espalha apenas uma vez
                }
            }
        }
    }
}

public class Principal{
  public static void main(String[] args){
    Simulator simulator = new Simulator();
  }
}
